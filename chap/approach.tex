\chapter{算法设计}
\section{Approach}
\label{sec:approach}
正如之前提到的，我们算法的基本思想是把C预处理器当作一组重写规则，
而反向变换就是这些规则相应的逆向规则。
在本章钟，我们会先描述本项目的C预处理器的模型（\secref{sec:forward}）。
然后我们会描述该系统所支持的修改操作。
接着我们会集中阐述其中第一种操作：替换操作的处理方法（\secref{sec:changes}）。
因为我们需要吧每一条重写规则反向应用，因此我们需要记录下预处理时使用
重写规则的顺序（\secref{sec:changes}），然后按照顺序依次为这些规则生成反向变换（\secref{sec:steps}）。
我们也会讨论这些步骤/过程为何能满足我们之前讨论的双向预处理器的五条性质（\secref{sec:correctness}），
并且给出一个更优化的算法。
最终，我们会讨论如何把不同类型的修改操作都转换成替换操作（\secref{sec:extend-other-changes}）。


% We introduce our
% approach in the following steps. First, we present our model of
% forward preprocessing, which forms the basis of the correctness
% discussion (\secref{sec:forward}). Second, we introduce a model for
% encoding changes on the preprocessed code (\secref{sec:changes}) and
% describe how to backward transform one type of changes: replacement of
% a token
% (\secref{sec:backward}). % We introduce two core concepts, rewriting step and
% % rewriting action, for recording the process of a forward
% % transformation and perform the backward transformation.
% The backward transformation is based on tracing the forward
% transformation as rewriting steps (\secref{sec:steps}).
% We also
% discuss how this process satisfies the requirements and laws (\secref{sec:correctness}). Finally, we
% discuss how to convert other types of changes into replacement (\secref{sec:extend-other-changes}).

为了读者可以更快理解我们算法设计的思想，我们暂时只考虑C预处理器指令的一个子集：
去除 \# 操作和 \#\#操作，去除~\code{\#include}~操作，也不考虑宏出现循环调用的情况。
我们会在之后的章节中（\secref{sec:fullC}）讨论如何把子集上的模型扩充到
支持全部C预处理指令的完整模型。

\newcommand{\dstart}{\ensuremath{\langle\#}\xspace}
\newcommand{\dend}{\ensuremath{\rangle}\xspace}
% \newcommand{\env}{\ensuremath{CTX}\xspace}

\subsection{模拟正向变换：预处理}\label{sec:forward}
我们把C预处理程序需要处理的程序看作词（\emph{token}）的一个序列。
为了从词序列中识别出预处理指令，我们依赖于两个特征词：
行首的\#符号和该行最后的换行符。
我们同时也假设当前环境中所有定义的宏都存储在环境变量\emph{$context$}里。

我们把C预处理器语法看作是重写规则的一个集合。
每个重写规则都有$guard \hookrightarrow action$这样的形式。
当$guard$是真时，$action$会把当前词序列的前几项替换成指定的词，
然后在替换的位置后继续下一条替换指令。

在模型中，$guard$和$action$ 都可以被看作是函数。
$guard$函数输入输入时当先剩下的词序列和当前的上下文环境$context$，
它将会输出一个表示是否要把当前规则应用到现在的词序列的布尔值。
$action$函数把当前还剩下的词序列，上下文环境当作输入，然后生成
一个四元组 $(finalized, changed, 
restIndex, newContext)$。
这个四元组中的变量含义如下：
$restIndex$表示在这变量之前的词都已经被重写规则处理过了。
在这些被处理过的词序列中，$finalized$表示了一串不需要再应用规则的词序列，
而$changed$是可能还需要呗扫描的序列。
而最后一个变量$newContext$ 代表着更新过的上下文环境。

有了这些定义后，我们算法中的正向变换部分在算法~\ref{alg:forward}中展示。
该算法循环应用规则$R$直至整个词序列都被处理。


% , where $guard$ is a condition to
% determine whether this rule can be applied to the head of the current token
% sequence, and $action$ takes a subsequence from the beginning of the
% sequence, replaces it with another sequence, and separates the
% replaced sequence into 
% into a finalized sequence and the remaining sequence, where the
% finalized sequence do not need to be further scanned and the remaining
% sequence needs to be scanned. A forward transformation iterates
% all rules, and applies the first applicable rule until the no more
% token need to be scanned.

\begin{algorithm}
  \newcommand\mycommfont[1]{\rmfamily{#1}}
  \SetCommentSty{mycommfont}
  \caption{Algorithm for forward preprocessing  \label{alg:forward}}
  \KwIn{token sequence $src$, rule list $R$}
  \KwOut{new token sequence $res$}
  $ctx \leftarrow \{\}$\;
  \While{$src.length > 0$}{
    \For{$r \in R$}{
      \If{$r.guard(src, ctx)$} {
        $(finalized, hanged, rest, ctx') \leftarrow r.action(src, env)$\;
        break\;
      }
    }
    $res \leftarrow res + finalized$\;
    $src \leftarrow changed + src.sub(rest)$\;
    \tcp{$sub(l)$ returns a
      subsequence starting from $l$} 
    $ctx \leftarrow ctx'$\;
  }
 % {\small Function $guard$ takes the remaining token sequence and the current definitions as
 % input, and returns a Boolean value to denote whether the rule can be
 % applied. $action$ takes the token sequence and the definitions
 % as input, and returns a token sequence that needs not be scanned, a
 % token sequence needs to be further scanned, and an updated set of definitions.}
\end{algorithm}

在C预处理情况中，规则列表$R$中总共有四个规则。
其中一个处理条件预处理指令，例如$\#if$, $\#ifdef$；
一个处理其他的预处理指令，这样我们可以用它来清除预处理指令并且更新上下文环境；
一个处理宏调用；
最后一个处理普通字符文本。
这四个规则如下定义：

\begin{itemize}
\item 规则1: 这个规则处理条件编译选项。$guard$函数将判定当前词序列的开头是否是一个独立
  的预处理条件指令，例如$\#if$，$\#ifdef$。如果为真，
  $action$函数首先会在当前上下文环境中检验条件选项是否为真，然后根据是否为真选择使用
  真值分支或假值分支编译。
  选择分支后，用该分支替换原有的指令，并把替换成功的新词序列记录在$changed$里。
  而$finalized$是空的。
\item 规则2: 这个规则处理其余所有预处理指令。$guard$函数将判定当前词序列的开头是否是一个
  独立的预处理指令。如果为真，
  $action$函数会解析这条指令，并对当前上下文环境做出必要的调整，比如添加一条宏定义。
  最后，该指令之后的词下标将会被记录成$restIndex$，而$finalized$和$changed$为空。
\item 规则3: 这条规则会展开宏调用。$guard$函数将判定当前词序列的开头第一个词是否是一个
  对象宏调用（\emph{object-like macro}）或者当前词序列的开头前两个非空白词是否是是一个
  函数宏调用（\emph{function-like macro}）和一个开括号。如果为真，
  $action$函数会做以下两个步骤的操作：
  \begin{itemize}
  \item 首先，我们会用规则3和规则4循环调用处理参数\footnote{在C预处理器中未定义
    把预编译指令放在参数中的操作~\parencite{CStandard}。在次我们认为在
    参数中不存在预处理指令}。
  \item 然后，我们把宏展开中各个参数出现的位置都替换成已经处理完了的宏参数。
    整个展开的部分都被记录在$changed$里，而$finalized$是空的，$restIndex$记录
    了宏调用之后的第一个词的位置。
  \end{itemize}
\item 规则4: 这个规则处理那些没有被其余规则处理的普通文本自负。$guard$函数总是返回真。
  $action$函数会把词序列中的第一个词放入$finalized$中，返回一个空的$changed$，
  并把下一个词的下标标记为$restIndex$。
\end{itemize}

让我们来看一个例子来理解这些规则的应用。考虑以下程序。
\begin{equation}
\begin{minipage}{0.4\columnwidth}
\begin{lstlisting}
#define x 100
hello x
\end{lstlisting}
\end{minipage}
\label{eqn:smallexample}
\end{equation}
% To preprocess this program, we recursively apply the rules over the
% program. 
当我们的系统处理这段代码时，第一个能应用的规则是规则2。
它会把第一个宏定义解析出来，存储在上下文中，并把接下来的下标移动到下一行。
这时剩余的词序列为~\code{hello x}。
接着应用规则4，并把~\code{hello}移动到$finalized$的序列中。
然后应用规则3，把宏调用 \code{x} 展开成 \code{100}。
最终，系统将会再次扫描一遍 \code{100} 并使用规则4把它移动到$finalized$序列中。
当剩余词序列为空时，整个处理过程就停下了。

% From the definitions of the rules we can prove a simple property. For
% any rule $r$, let $r.guard(src, c)$ be true and $r.action(src, c) = (f, h, restIndex, c')$. Supposing
% $src'$ differs from $src$ only for the tokens at or after $restIndex$,
% we know that $r.guard(src, c)=true$ and $(f, h, restIndex, c') = r.guard(src', c)$. In other
% words, if we change the 

\subsection{模拟修改}\label{sec:changes}
程序编辑工具可以通过各种各样的方式对一段程序进行修改。
本文中我们考虑三种基本的修改：替换、插入和福祉。
这三种基本的修改是我们在分析了现有的主流代码修复工具
例如GenProg~\cite{le2012genprog} 和 SemFix~\cite{nguyen2013semfix}
之后总结而成。
这些代码修复工具往往会拷贝或创造一个语句来替换现有语句或插入来修改程序错误。

这三种操作都直接地对词序列进行操作。
一个替换操作描述为一个二元对$(l, s)$，其中$l$是要被替换的词的位置，
而$s$是将要替换在$l$位置的一串词序列。
一个插入操作也是一个二元对$(l, s)$，其中词序列$s$将会被插入到位置$l$
之后。
一个拷贝操作时一个三元组$(l, l_b, l_e)$。它表示从位置$l_b$（包含）起至
$l_e$（不包含）的词序列将会被拷贝插入到位置$l$的词之后。

我们可以看出替换操作涵盖的删除操作。一个形式为$(l, [])$
的替换操作就代表删除了一个词，其中$[]$表示空序列。

本章接下来的部分，我们将讨论如何实现一个可以处理替换操作的反向变换操作。
我们也会讨论如何把其他两种操作转换成替换操作。
% If a change set contains only
% replacements, we could also interpret the change set as a total function
% mapping each index into a token sequence, where unchanged indexes
% are mapped to the original tokens at the indexes.

\subsection{重写步骤}\label{sec:steps}
正如在序言中介绍过的，我们的反向变换操作会逆向实施之前提到的重写规则。
为了生成好的反向变换，我们设计了一个数据结构来记录下正向展开时
使用了哪些规则，分别应用在代码的哪个部分。
我们把这种记录的数据结构称作 \emph{重写步骤}。
每一个重写步骤都是一个四元组， $(src, i, ctx, r)$。
其中$r$表示规则$r$已经被应用到一段子序列$src$。
自序列位置在$i$，应用规则时的上下文环境为$ctx$。
其中$src$总是代表了暂时的词序列，区别于源序列与最终系列，是应用了
之前所有规则后生成的临时序列。

相应的，一个完整的正向序列会被记录成一个重写步骤序列。
比方说，正向处理之前例子中的代码段 \ref{eqn:smallexample} 时，
我们的算法会产生以下的重写步骤序列：
$(P, 0, \{\}, R2)$，$(hello\ x, 0, \{x\}, R4)$，$(hello\ x, 1, \{x\}, R3)$，和
$(hello\ 100, 1, \{x\}, R4)$。
其中$p$是源程序。

% We use a data structure to record how a rule application changes the
% token sequence, which is the key to our bidirectionalization. We call
% this data structure \emph{rewriting step}. Intuitively, we may first
% consider 
% A rewriting step is a
% triple, $(ctx, args, body)$. The first component, $ctx$, is the
% current context. The rest two steps contains two types of rewriting
% actions, argument expansions and body expansions, which are inner
% changes performed to form a rewriting step. Component $args$ contains
% a set of argument expansions, and $body$ is a body expansion.

% An argument expansion records how an argument to a macro invocation is
% expanded, and is recursively defined as a sequence of
% rewriting steps.

% A body expansion 


\subsection{考虑替换操作的反向变换}\label{sec:backward}
反向操作的基本思想是把预编译后代码上的修改通过重写规则序列
一步步映射到预处理前的代码上。这样当我们再跑一次正向变换时，
只会有两种情况：1. 程序会按照相同的重写规则再次正向展开
2. 程序会按照登记啊的重写规则序列展开，这个规则序列长度可以是0。
我们设计的反向变换操作在算法~\ref{alg:backward}中。
其中$backward$函数沿着每一个重写步骤映射程序上的修改，
或者是当它发现没有合适的修改可以映射时报错。

\begin{algorithm}
  \newcommand\mycommfont[1]{\rmfamily{#1}}
  \SetCommentSty{mycommfont}
  \caption{Algorithm for backward transformation \label{alg:backward}}
  \KwIn{a sequence of rewriting step $rs$}
  \KwIn{a set of replacements $c$}
  Reverse sequence $r$\;
  \For{$r \in rs$}{
    $c \leftarrow backward(rs, c)$\;
    \If{$backward$ failed}{print ``Changes cannot be applied.''\; \Return{}\;}
  }
  \Return{$c$}\;
\end{algorithm}

我们从伪代码中可以看出，实现反向变换的关键在于如何实现 $backward$ 函数。
$backward$ 函数的行为随着规则的不同而改变。
在此，我们根据复杂度，从简单到复杂讨论该函数的功能。

首先，如果当前重写步骤是依据规则2处理的，这意味着此处处理了一个非条件的
预编译指令，正向预编译时，这条指令被预处理器删除。反向变换会根据预处理
指令的位置来考虑是否要偏移操作。比方说，考虑以下的代码程序：
\begin{lstlisting}
#undef hello
hello
\end{lstlisting}
现在如果我们有一个$(0, x)$的替换操作，那么在这个例子中，
$hello$会被替换成$x$。
$backward$函数会把该替换操作位移到$(4, x)$来保证当前
替换操作依然是作用在$hello$这个词上。

第二，如果当前重写步骤是依据规则1处理的，这意味着此处预处理器
处理一个条件预处理指令。预处理器当时把这一段替换成了条件指令的一个分支。
在反向变换中，我们把在分支上发生的修改操作映射到原来的条件指令中，
同时计算必要的偏移量等。
因为我们不会改变宏的定义，此处的条件预处理指令在再次预处理时，
还是会选择相同的分支进行替换。

第三，如果当前重写步骤是依据规则4处理的，这意味着此处预处理器
处理了一段非指令非宏调用的普通文本字符。正向预处理器应该把一个
词放到$finalized$里去了。
反向变换需要保证在修改过后的词序列上，依然会应用规则4。
举例来说，如果用户把$hello\ c$ 中的 $hello$ 替换成了 $a\ b$，
我们需要检查，从$a$开始，是否唯一的预处理办法就是应用两次规则4来替换当前序列。
在这个例子中，只有当规则4的$guard$函数能够在要么 $a\ b\ c$ 或者 $b\ c$上返回真才行。
这时候就会发生反向变换失败的情况。
比方说，如果程序编辑程序给出的修改时把$hello$修改成$x$，
其中$hello$并不是宏调用，但$x$是宏调用。那么此时应该报错。
另一个情况是程序编辑程序把$GARRAY\ hello$替换成了$GARRAY\ (hello)$。
此时$GARRAY$是一个含有一个参数函数式宏调用。
在这种情况下，之前$GARRAY$被当作文本使用规则4重写因为它之后并不是括号。
而在新的序列中，$GARRAY$变成了一个宏展开。此时很有可能造成程序错误。
以上两种情况$backward$函数都应该报错，自动程序并不能轻易地把修改映射到代码中去。

% ???????????

最后，如果当前重写步骤是依据规则3处理的，这意味着此处预处理器
处理了一个宏调用。这种情况是最复杂的。
规则3包含了两个步骤。我们首先试图沿着两个步骤逆向重写代码。
如果两个步骤中有一个失败了，那我们只能试着展开宏调用。

在第二个小步骤中，

In the second sub step, the occurrences of parameters in a macro body
are replaced by expanded arguments. The backward transformation 
maps the changes back to the arguments. There are two cases where an
expansion may be triggered: (1) tokens that are not from the
arguments are changed, and (2) multiple occurrences of the same
parameter are changed to different values. 
For example, giving the following piece of code,
\begin{equation}\label{eqn:expansion}
  \begin{minipage}{0.8\columnwidth}
\begin{lstlisting}
#define x 1
#define plus(a) a+a
plus(x);
\end{lstlisting}
  \end{minipage}
\end{equation}
if we changes $1+1$ into $1-1$ or $1+2$, an expansion will be triggered.

In the first sub step, the arguments are preprocessed. The backward
transformation recursively call $backward$ to propagate the changes
along the rewriting steps of each argument. Finally, a safety check is
performed on the propagated changes: if the changed argument contains
a comma at the top level (and the comma is not enclosed by a pair of parentheses) or
any unmatched parenthesis, we trigger an expansion. This is
because a comma or an unmatched parenthesis can break the original
structure of arguments.

If the backward transformation on any of the sub step fails, we expand
the macro invocation. The expansion will generate changes that replace
the macro invocation with its expanded body. As an example, let us
assume the second $1$ in $1+1$ is changed into $2$ in code
piece~\ref{eqn:expansion}. After backward transformation, the
propagated change will replace $plus$ in $plus(x)$ with $x+2$ and
delete $(x)$.

% To
% perform the macro expansion, we need to generate the expanded form to
% replace the macro invocation.
The key to the expansion is how to construct the replacing sequence,
$x+2$. From the forward transformation we know that the unchanged
preprocessed token sequence is $1+1$, and both $1$s are from the
argument $x$. So we copy the rewriting steps of $x$ to the locations
of the two $1$s, and use the copied rewriting steps to propagate back
the changes on the $1$s. The first $1$ is not changed, so the original $x$
is kept. The second $1$ is changed into $2$, so the macro invocation
$x$ is also expanded, and we get the final text $x+2$.

%We first construct an unchanged expanded form, and then
% propagate back the changes along the unchanged expanded form. First,
% we replace the occurrences of parameters in the macro body by either
% the preprocessed argument or the unpreprocessed argument (both the original
% arguments without user changes). An occurrence of a parameter is
% replaced by a preprocessed argument if any of the following conditions is
% satisfied.
% \begin{itemize}
% \item The preprocessed argument starts with a left parenthesis.
% \item The preprocessed argument contains a top-level comma.
% \item The preprocessed argument contains any unclosed parenthesis.
% \item The preprocessed argument becomes different if we preprocess it again.
% \end{itemize}
% Otherwise, the occurrence is replaced by an unpreprocessed argument. In
% the previous example, $x$ does not satisfy any of the above condition,
% so $a$ in the body of $plus$ is replaced by the unpreprocessed
% argument, forming $x+x$.

% Next, 
% for any
% occurrence of a parameter replaced by an unpreprocessed argument, the
% rewriting steps of the argument is first copied at the new location to
% preprocess the argument, and then we copy

However, we cannot always copy the rewriting steps of an argument to
the occurrences of its corresponding parameter. Basically, when we
copy the rewriting step of an argument, we are assuming that the
occurrence of the parameter can be replaced by its unpreprocessed
argument, and all rewriting steps behave exactly the same as before.
For example, when expanding $plus(x)$, we can replace the two
occurrences of $a$ by $x$, forming $x+x$ where the two $x$ expands
exactly the same way as the argument $x$, forming $1+1$. However, this is
not always the case. Let us consider the following code.
\begin{equation}\label{eqn:expandToParentheses}
  \begin{minipage}{0.8\columnwidth}
\begin{lstlisting}
#define p (x)
#define pplus(x) plus x hello
pplus(p)  
\end{lstlisting}
    \end{minipage}
\end{equation}
With the macros defined in code piece \ref{eqn:expansion}, the above code
is preprocessed into to $1+1\ hello$. However, if we need to expand
$pplus(p)$, we cannot expand it into $plus\ p\ hello$, because it will
only expand to $plus\ (1)\ hello$. This is because the use of $p$
instead $(x)$ breaks the original macro invocation. % In fact, all the
% first three conditions listed above are designed to prevent this case:
% the expanded macro is used as part of another macro invocation and
% replacing it with the unexpanded form may break the macro invocation.

As a result, we have to add a safety check when we copy rewriting
steps. We copy the rewriting
steps of an argument only if none of the following conditions is satisfied.
\begin{itemize}
\item The preprocessed argument starts with a left parenthesis.
\item The preprocessed argument contains a top-level comma.
\item The preprocessed argument contains unclosed parentheses.
\item The preprocessed argument becomes different if we preprocess it
  again.
\end{itemize}
The first three conditions correspond to situations similar to the
above example: the preprocessed argument is used as part of another
macro invocation in the expanded form, and replacing it with the
unpreprocessed one will break the macro invocation.  
% In the previous example, when $1+1$ is replaced by $1+2$, we expand
% the macro invocation $plus(x)$. Since the argument $x$ expands to
% $100$, the three conditions are satisfied and the body is replaced as
% $x+x$. Next we use the rewriting step of expanding $x$ to propagate
% the changes on the two $1$s. The first $1$ is not changed, so the
% original $x$ is kept. The second $1$ is changed into $2$, so the
% original macro invocation $x$ is also expanded, and we get the final
% text $x+2$, which is used to form a replacement of $plus$.
% To see an example where we should use the expanded argument, let us
% consider the following code.
% \begin{lstlisting}
% #define p (x)
% #define pplus(x) plus x hello
% pplus(p)  
% \end{lstlisting}
% With the definitions in code piece \ref{eqn:expansion}, the above code
% expands to $1+1 hello$. However, if we need to expand $pplus(p)$, we cannot
% expand it into $plus p hello$, because it will only expand to $plus
% (1) hello$. This is because the use of $p$ instead $(x)$ breaks the
% original macro invocation. In fact, all the first three conditions listed
% above are designed to prevent this case: the expanded macro is used as
% part of another macro invocation and replacing it with the unexpanded
% form may break the macro invocation.
The last condition corresponds to the following case.
\begin{lstlisting}
#define id(x) x
id(plus p)
\end{lstlisting}
This piece of code expands to $1+1$, but if we expands $id(plus\ p)$
into $plus\ p$, the other macro expansions will be blocked. In other words, with macro
invocation, an argument will be scanned twice, but when the macro
invocation is expanded, an argument will only be scanned once. We need
to make sure this does not affect correctness.

\subsubsection{Correctness}\label{sec:correctness}
We can directly reason that the backward transformation satisfies
Requirements 1, 3, 4 and 5. Requirement 2 will later be evaluated by
our experiments. Requirement 1 holds because we never propagate
changes to macro definitions. Requirement 3 holds because if we happen
to introduce a new macro invocation, we must have changed a normal 
token that should be preprocessed by R4 into part of a macro
invocation, and the check in R4 will prevent such a change.
Requirement~4 holds because we introduce new changes only when we
expand a macro invocation, and we would not expand a macro invocation
if nothing is changed. Requirement 5 has been reasoned throughout this
subsection. To prove it formally, we need to inductively prove that each
rewriting step either still behaves the same on the changed steps, or
is replaced by a sequence of equivalent rewriting steps (the size of
the sequence may be zero). A tricky point is when we copy rewriting
steps of arguments to the
expanded method body, the copied rewriting steps may be
mixed with later rewriting steps. We can show that, still by
induction, the order of applying these rewriting steps can be changed
without affecting the final result. We omit the details due to space
limitations.

\subsubsection{Optimization}\label{sec:optimization}
In the current algorithm, we need to record the whole program after
each rewriting step, even if only a small portion has changed. In the
backward direction, we also need to shift all changes at each step.
This contributes to a major performance penalty of the algorithm.

To optimize the algorithm, we first divide the original
token sequence into a set of subsequences, where each subsequence is
independently preprocessed by a set of rewriting steps. In this way, we
can treat each subsequence as an independent program to perform the
backward transformation, and then merge the changes. Giving a rewriting
step $(src, i, ctx, r)$, if the token at $i$ is not generated by a
preceding rewriting rule, i.e., is from the original program, then we
say the location right before $i$ is a \emph{splitting point}. With
this definition, we guarantee that no rule application crosses a
splitting point. We divide the original program into
subsequences along the splitting points, and perform the backward transformation
independently for each subsequence before merging the changes. % A
% splitting point guarantees that no rule application replaces a sub
% sequence that crossing the splitting point, so we can split the
% original program at splitting points. 
When merging changes from two subsequences, we need to check that the
preprocessed version of left sequence and the unpreprocessed version of
the right sequence would not form a new macro invocation. This check
was performed by R4 in the unoptimized algorithm.% \todo{And then rollback? I am worried that this
  % handwaving discussion may annoy people who are more expert in
  % parallel algorithms. Probably it is better to shorten the discussion
  % and and emphasize that it is implemented. The current writing sounds
  % like a piece of proposal for future work.}

For example, code piece~\ref{eqn:smallexample} can be divided into
three subsequences: the macro definition, $hello$, and $x$. Suppose
$plus$ is a macro defined earlier. If the user changes $hello$ into
$plus$ and changes $100$ into $(x)$, a new macro invocation is formed
across the boundary and we should report a failure.


\subsection{Extending to full CPP}\label{sec:fullC}
In this sub section we discuss how we can extend the above algorithm
to support full CPP. Due to space limitations, we
only discuss the main ideas without the full details.

To support \# and \#\# operators in forward preprocessing, we need to add
two additional types of sub steps in R3, one for stringifying tokens
and one for concatenating tokens. Furthermore, parameters used with
these operators are replaced by their unpreprocessed forms but not their
preprocessed forms, so in the first sub step we need to keep both the
unpreprocessed and the preprocessed forms. % In the backward transformation, we
% need to also propagate the changes along the two new sub steps, and
% trigger a macro expansion when the propagation cannot be completed.
% Furthermore, in the first sub step we need to check if the expanded
% form and the unexpanded are changed consistently, and triggers a macro
% expansion otherwise. In the macro expansion, we need to evaluate \#
% and \#\# operators on the body before expansion, as the two operators
% cannot exist on the top level.
We need to add three extensions to the backward transformation. First,
we need to design the backward transformation for the two new sub
steps. Second, we need to add a safety check to determine whether the
unpreprocessed form and the preprocessed form are changed
consistently. Finally, when expanding a macro, we should not try to
recover \# and \#\# operators as the two operators cannot exist on the
top level.

To support \#include in the forward preprocessing, we need to add
another rewriting rule to support \#include. In the backward
transformation, we need to trace how changes are propagated to each
file, and check changes propagated back from different \#include
directives of the same file are consistent.

Finally, % with our current rewriting rules, a macro definition
% ``$\#define\ x\ x$'' will expand forever. To prevent this, CPP does
% not expand a macro invocation found during the expansion of an
% invocation to the same macro.
CPP does not allow expanding a macro within its own expansion to prevent
infinite loops. 
To support this, we need to add finer
control of the context in our forward rewriting rules. When we are
dealing with the tokens expanded from an invocation to macro $m$, the
definition of $m$ should be removed from the current context.

\subsection{Extending to other types of changes}\label{sec:extend-other-changes}
We have discussed how to deal with replacements. Now let us proceed to
insertions and copying. Note that an insertion can be directly
converted into a replacement. If we insert a token $y$ before a token
$x$, we can convert it as replacing $x$ with $y\ x$. However, this
direct conversion may cause unnecessary macro expansions. For example,
if we insert $y$ before $100$ in the preprocessed code piece
\ref{eqn:smallexample}, $hello\ 100$, we should not expand $x$ in
the backward transformation, but if we model the insertion as
replacing $100$ with $y\ 100$, our backward transformation will expand
$x$ because its body has been changed.

The above example exhibit an insertion at a splitting point, and such
an insertion is guaranteed not to expand
macros. To reduce the number of unnecessary expansions, % we give special
% treatment to insertions at splitting points. % \todo{So
% we only reduce but not minimize expansions? Why are splitting points special?}
% Since the splitting
% points are not covered by any macro invocation, the insertions at
% these locations should not expand any invocation.
We treat the
inserted token sequence at a splitting point as an independent sequence and check
whether only R4 is applicable to it, since there is no way to put it
back if any other rewriting rules can be applied on the inserted
sequence. Then we use the same method used in the optimized algorithm
to merge the subsequences.

The copy operation is similar to insertion. The only difference is
that copied segments may contain macro invocations and we shall
try to recover these macro invocations. For this, we perform a
special backward transformation. First, we generate changes on the
preprocessed code that deletes all tokens except the segments being
copied. Then we perform a backward transformation by ignoring
rewriting steps with R1, R2, and R3 whose associated macro is not
defined or defined differently at the target position. In this way we
ensure that only macros that is defined at the target positions are recovered.
Then, we insert the token sequence returned by the backward
transformation to the target position.

% Instead, we deal with an insertion by concatenating three
% token sequences: the tokens before the insertion, the inserted tokens,
% and the tokens after the insertion. We first generate a change that
% deletes all tokens before the insertion, and perform a backward
% transformation to get the token sequence before insertion.
% In the above example, we first generates a change to delete $100$, and
% a backward transformation will give us 


% \subsection{Approach Overview}

% There are three key issues.
% \begin{itemize}
% \item We show that different preprocessor directives and macro
%   operators can be captured by a unified concept, text unit. The
%   execution of the preprocess can be captured by the composition of
%   text units, which enables a structural decomposition of the backward transformation.
% \item Even with the composition structure, we still need to deal with
%   the intersection of each type of text unit and each change
%   operation. We further show that there exists a core change
%   operation, replacement. We only need to consider the propagation of
%   replacement on each type of text unit. The other change operations
%   can be easily mapped to the core operation.
% \item Since our bidirectional transformation not only changes the
%   values transformed by the transformation but also the transformation
%   program itself, it will produce two outputs, one is the changed
%   program and one is the change to the data. When we apply the change
%   to the data to the program, we get the final result.
% \end{itemize}


% \newcommand{\replace}[2]{\ensuremath{[{#1}]\backslash {#2}}}
% \newcommand{\copyOpr}[3]{\ensuremath{[{#1},{#2}]\rightarrow [{#3}]}}
% \newcommand{\del}[2]{\ensuremath{\cancel{[{#1},{#2}]}}}
% \subsection{Modeling the Changes}

% A location or offset of a character in the source code file is 
% A location in the source code file is a pair $(f, o)$, where $f$ is
% the name of the source file, and $o$ is the offset from the start of
% the file, but treating all continuous whitespace characters as one character.

% A replacement is a pair $(l, s)$, where $l$ is a location on which the
% character is not a whitespace, and $s$ is
% a string that will replace the character at $l$.

% An insertion is a pair $(l, s)$, where $l$ is a location on which the
% character is a whitespace, and $s$ is a string that will be inserted
% at $l$.

% A copy is a pair $(l_t, l_b, l_e)$, showing the string between $l_b$
% and $l_e$ is copied into the location $l_t$, where $l$ is a location
% on which the character is a whitespace. 





% % Three atomic operations: replace, insert, copy, and delete.

% % Replace: a tuple $(p, s)$, denoted as $\replace{p}{s}$, showing the char at $p$ is replaced by $s$.

% % Copy: a tuple $(b, e, p)$, denoted as $\copyOpr{b}{e}{p}$, showing the string between $b$ and $e$ is
% % copied to replace the character at $p$.

% % Delete: a tuple $(b, e)$, denoted as $\del{b}{e}$, showing the string between $b$ and $e$ is
% % deleted.

% % Conflict rules: copy may overlap with the other two operations, but
% % the copied content is not modified. 

% % A set of standard operations: replace, copy, move, and delete.

% % RReplace: a tuple $(b, e, s)$, where the string between $b$ and $e$ is
% % replaced by $s$. RReplace can be modelled by Replace $(b, s)$ and
% % delete $(b, e+1)$.

% % CCopy is equal to copy.

% % DDelete is equal to delete.

% % MMove is a tuple $(b, e, p)$ that is equal to copy $(b, e, p)$ and
% % delete $(b, e)$.

% % \begin{definition}[Correctness]
  
% % \end{definition}


% % \begin{definition}[Completeness]
  
% % \end{definition}

% \subsection{Modeling Macro Expansion}
% % confluence in backward transformation? -- a sub case of correctness

% A text segment is a sequence of text units. A text unit is one of the
% following types: 




% \subsection{Forward Transformation}

% \subsection{Backward Transformation}

% We need to perform a check of the name collision

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
