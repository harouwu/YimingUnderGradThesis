\chapter{总结}
\label{sec:conclusion}

为程序编辑工具处理C预处理器十分困难。
现有的程序编辑工具往往无法正确处理预处理指令、或是直接不处理预处理指令。
例如现有的C语言工具：GenProg~\parencite{le2012genprog,le2012systematic}，RSRepair~\parencite{QiMLDW14}，和
SemFix~\parencite{nguyen2013semfix}。
这三个工具都只在预处理后的代码上工作。

本文中我们使用双向变换的方法提出了一种轻量级的双向C预处理器。
我们模拟了正向C预处理器算法，并将其转化到重写规则模型中。
我们根据重写规则模型定义了重写步骤数据结构。
我们依据重写步骤结构生成反向变换，并讨论了该双向预处理过程是否满足应有的5条性质。

另外，我们在Linux内核上验证了我们的方法，并和另外两种基本的
做法进行比较。
实验的结果显示相较于其他方法，我们的方法破坏了相当少的宏调用，
并且总是可以给出正确的修改，而其他方法有时不行。

总的说来，该方法把程序编辑工具从预处理器带来的设计麻烦中解脱出来。
使得程序编辑工具能专注于预处理之后的代码，达到更模块化的设计效果。
这是已知的第一种双向预处理器。

从理论上说，C预处理器涉及到的问题也可以看作是转换系统问题中特殊的一类。
在这类问题中，转换程序和数据可能同时被转换。
例如双向变换PHP设计~\parencite{wang2012automating}。
现有的方法~\parencite{wang2012automating}往往使用十分复杂且有针对性的设计。
其中关于双向变换性质的定义和正确性的讨论也往往很复杂。
本文所提出的方法对这一类的问题都有适用价值：该方法把转换程序当作数据，
并在更高一层的操作语义上生成双向变换。
我们衷心希望未来能看到更通用的理论能够完美解决这一类问题。



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
